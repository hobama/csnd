// -*- coding: utf-8-unix -*-
#include "avrocpp.hpp"
#include "ar.hpp" // <- generated by avrogencpp
#include "util.hpp"

#include <chrono>
#include <iostream>
#include <random>
#include <stdexcept>
#include <sstream>

using namespace std::chrono;

#include <boost/iostreams/device/back_inserter.hpp>
#include <boost/iostreams/filter/zlib.hpp>
#include <fmt/format.h>

// avro-cpp
#include "avro/DataFile.hh"
#include "avro/Compiler.hh"
#include "avro/Stream.hh"

namespace {

const std::string AR_SCHEMA(
    "{\"name\": \"accel_record\",\
      \"type\": \"record\",\
      \"fields\": [\
       {\"name\": \"x\", \"type\": \"float\"},\
       {\"name\": \"y\", \"type\": \"float\"},\
       {\"name\": \"z\", \"type\": \"float\"},\
       {\"name\": \"sample_count\", \"type\": \"int\"},\
       {\"name\": \"start_time\", \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}},\
       {\"name\": \"end_time\",   \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}}]}");

const std::string AVRO_SCHEMA_KEY("avro.schema");
const std::string AVRO_CODEC_KEY("avro.codec");
const std::string AVRO_NULL_CODEC("null");
const std::string AVRO_DEFLATE_CODEC("deflate");

typedef boost::array<uint8_t, 4> Magic;
const Magic magic = { { 'O', 'b', 'j', '\x01' } };

// DataFile.cc で定義されている関数。無名の名前空間にありアクセスできないためコピペする。
boost::iostreams::zlib_params get_zlib_params() {
  boost::iostreams::zlib_params ret;
  ret.method = boost::iostreams::zlib::deflated;
  ret.noheader = true;
  return ret;
}

}

namespace csn {

class serializer_avrocpp::impl {
 public:
  impl(csn::avro_codec c);
  ~impl() {}
  std::shared_ptr< std::vector<uint8_t> > serialize(std::shared_ptr< std::vector< std::shared_ptr< csn::accel_record > > > ars);
 private:
  std::mt19937 _mt;
  avro::ValidSchema _schema;
  csn::avro_codec _codec;
  avro::DataFileSync _sync;
  std::map< std::string, std::vector<uint8_t> > _metadata;
  void set_metadata(const std::string& key, const std::string& value);
};

}

csn::serializer_avrocpp::impl::impl(csn::avro_codec c) : _codec(c) {
  std::random_device seed_gen;
  std::mt19937 _mt = std::mt19937(seed_gen());

  std::stringbuf sbuf(AR_SCHEMA);
  std::istream is(&sbuf);
  avro::compileJsonSchema(is, _schema);

  std::ostringstream oss;
  _schema.toJson(oss);
  set_metadata(AVRO_SCHEMA_KEY, oss.str());

  switch (_codec) {
    case csn::avro_codec::null:
      set_metadata(AVRO_CODEC_KEY, AVRO_NULL_CODEC);
      break;
    case csn::avro_codec::deflate:
      set_metadata(AVRO_CODEC_KEY, AVRO_DEFLATE_CODEC);
      break;
    default:
      throw std::runtime_error("UNSUPPORTED CODEC");
  }
}

void csn::serializer_avrocpp::impl::set_metadata(const std::string& key, const std::string& value) {
  std::vector<uint8_t> v(value.size());
  copy(value.begin(), value.end(), v.begin());
  _metadata[key] = v;
}

std::shared_ptr< std::vector<uint8_t> > csn::serializer_avrocpp::impl::serialize(std::shared_ptr< std::vector< std::shared_ptr< csn::accel_record > > > ars) {
  if (ars == nullptr || ars->size() == 0) {
    throw std::invalid_argument("NO DATA TO FLUSH");
  }

  for (size_t i = 0; i < _sync.size(); ++i) {
    _sync[i] = _mt();
  }

  // シリアライズ
  std::unique_ptr<avro::OutputStream> out = avro::memoryOutputStream();
  avro::EncoderPtr enc = avro::binaryEncoder();

  // データはサイズを求めるために一旦out_dataにエンコードする
  std::unique_ptr<avro::OutputStream> out_data = avro::memoryOutputStream();
  enc->init(*out_data);
  for (const std::shared_ptr<csn::accel_record> a : *ars) {
    avro_serialize::accel_record ar;
    ar.x = a->x;
    ar.y = a->y;
    ar.z = a->z;
    ar.sample_count = a->sample_count;
    ar.start_time = duration_cast<milliseconds>(a->start_time.time_since_epoch()).count();
    ar.end_time = duration_cast<milliseconds>(a->end_time.time_since_epoch()).count();

    avro::encode(*enc, ar);
    enc->flush();
  }

  // write header
  enc->init(*out);
  avro::encode(*enc, magic);
  avro::encode(*enc, _metadata);
  avro::encode(*enc, _sync);

  // write data block
  int64_t objectCount = ars->size();
  avro::encode(*enc, objectCount); // A long indicating the count of objects in this block.
  if (_codec == csn::avro_codec::null) {
    int64_t byteCount = out_data->byteCount();
    avro::encode(*enc, byteCount); // A long indicating the size in bytes of the serialized objects in the current block, after any codec is applied
    enc->flush();
    std::unique_ptr<avro::InputStream> in = memoryInputStream(*out_data);
    avro::copy(*in, *out); // The serialized objects. If a codec is specified, this is compressed by that codec.
  } else if (_codec == csn::avro_codec::deflate) {
    std::vector<char> buf;
    {
      boost::iostreams::filtering_ostream os;
      os.push(boost::iostreams::zlib_compressor(get_zlib_params()));
      os.push(boost::iostreams::back_inserter(buf));
      const uint8_t* data;
      size_t len;

      std::unique_ptr<avro::InputStream> input = memoryInputStream(*out_data);
      while (input->next(&data, &len)) {
        boost::iostreams::write(os, reinterpret_cast<const char*>(data), len);
      }
    } // make sure all is flushed
    std::unique_ptr<avro::InputStream> in = avro::memoryInputStream(reinterpret_cast<const uint8_t*>(buf.data()), buf.size());
    int64_t byteCount = buf.size();
    avro::encode(*enc, byteCount);
    enc->flush();
    copy(*in, *out);
  } else {
    throw std::runtime_error("UNSUPPORTED CODEC ERROR");
  }

  enc->init(*out);
  avro::encode(*enc, _sync); // The file's 16-byte sync marker.
  enc->flush();

  boost::shared_ptr<std::vector<uint8_t>> buf = snapshot(*out);

  std::shared_ptr< std::vector<uint8_t> >result(new std::vector<uint8_t>());
  result->resize(out->byteCount());
  std::copy(buf->begin(), buf->end(), result->begin());
  return result;
}

csn::serializer_avrocpp::serializer_avrocpp(csn::avro_codec c) :
    csn::serializer(c),
    _impl(new csn::serializer_avrocpp::impl(c)) {}

csn::serializer_avrocpp::~serializer_avrocpp() {}

std::shared_ptr< std::vector<uint8_t> > csn::serializer_avrocpp::serialize(std::shared_ptr< std::vector< std::shared_ptr< csn::accel_record > > > ars) {
  return _impl->serialize(ars);
}
